# ZooKeeper

## ZooKeeper是什么

ZooKeeper是一个典型的分布式数据一致性的解决方案，分布式应用程序可以基于它实现租入数据发布/订阅，负载均衡，服务命名，分布式协调/通知，集群管理，Master选举、分布式锁和分布式队列等功能，可保证如下分布式一致性特性

- 顺序一致性 从同一个客户端发起的事务请求，最终将会严格的按照其发起的顺序被应用到ZooKeeper中去
- 原子性 所有的事务请求的处理结果在整个集群的应用情况上是一直的，要么整个集群所有的集群都成功应用了某个事务，要么都没有应用
- 单一视图性 无论客户端连接的是哪个ZooKeeper服务器，看到的服务端的数据模型都是一致的
- 可靠性 一旦服务端成功的应用了一个事务，并完成对客户端的响应，那么该事务所引起的服务端状态变更将会一直保留，除非另一个事务又对其进行了变更
- 实时性 ZooKeeper仅仅保证在一定的时间段内，客户端最终一定能够从服务端上读取到最新的数据状态

ZooKeeper使得分布式程序通过一个共享的、树形结构的名字空间来进行相互协调，ZooKeeper将全部的数据存储在内存中，以此来提高服务器吞吐，减少延迟。

ZooKeeper集群最少需要三个节点，每个节点都会在内存中维护当前的服务器状态，并且每个节点之间保持的互相通信，集群中存在超过一半的机器能够正常工作，就能保证对外提供服务。

每个客户端的请求都会产生一个唯一的、递增的编号，这个编号反映了所有事务操作的顺序。

### ZooKeeper集群

ZooKeeper集群引入了Leader、Follower和Observer三种角色，集群中所有的机器通过一个Leader选举过程来选定一份被称为Leader的机器，Leader服务器为客户端提供读和写功能，Follower和Observer都能提供读服务，唯一的区别在于，Observer不参与Leader选举过程，也不参与与写操作的'过半写成功'策略，因此Observer可以在不影响写性能的情况下提高集群的读性能。

### 会话（Session）

ZooKeeper中，一个客户端连接是指客户端和服务器之间的一个TCP长连接。客户端启动会，通过心跳检测和服务端保持有效的会话，可以向ZooKeeper服务器发送请求并接受响应，同时也能接受服务器的Watch事件通知。sessionTimeout用来设置超时时间，只要在超时时间内重新连上服务器，之前创建的session仍然有效。

### 数据节点（ZNode）

ZooKeeper将所有数据存储在内存中，数据模型是一颗ZNode Tree，由/进行分割路径，每个ZNode都会保存自己的数据内容，同时还会保存一系列属性信息。ZNode分为持久性和临时性两类。临时节点一旦客户端会话失效，临时节点会被移除。ZooKeeper允许用户为每个节点添加一个特殊属性：SENQENTIAL，一旦节点被标记这个属性，那么在这个节点被创建的时候会自动在其节点名后追加一个整型数字，这个整形数字是其父节点维护的自增数字。

### 版本

每个ZNode，ZooKeeper会为其维护一个叫做Stat的数据结构，Stat记录这个ZNode的三个数据版本，分别是version(当前ZNode版本)、cversion(当前ZNode子节点版本)、aversion(当前ZNode的ACL版本)。

### Watcher

Watcher事件监听器，允许用户在指定节点注册一些Watcher，在一些特定事件处罚的时候，服务端会将事件通知到订阅事件的客户端上去。

### ACL

ZooKeeper采用ACL(Acess Control Lists)策略进行权限控制，定义了如下5种权限

- CREATE 创建子节点的权限
- READ 获取节点数据和子节点列表的权限
- WRITE 更新节点数据的权限
- DELETE 删除子节点的权限
- ADMIN 设置节点ACL的权限

### ZAB (ZooKeeper Atomic Broadcast)ZooKeeper原子广播协议

ZooKeeper并没有完全采用Paxos算法，而是采用一种特别为ZooKeeper设计的崩溃可恢复的原子消息广播算法ZAB，来实现分布式一致性。ZooKeeper使用单一的主进程来接收并处理客户端的所有事务请求，并采用ZAB的原子广播协议，将服务器的状态变更以事务Proposal的形式广播到所有的副本进程上去。ZAB协议包括两种基本模式，分别是崩溃恢复和消息广播。

- 崩溃恢复 Leader服务器异常时，或者集群中国版的服务器中断与Leader的正常通信时，ZAB协议进入恢复模式并选举产生新的Leader服务器，当选举产生了新的Leader服务器，并集群中过半的机器与Leader服务完成状态同步之后，ZAB协议就会推出恢复模式。

- 消息广播 当集群中过半的Follower服务器完成和Leader服务器的状态同步，那么整个服务框架就可以进入消息广播模式，如果非Leader接收到客户端的请求，首先会将这个事务请求转发给Leader服务器

ZAB协议需要确保那些已经在Leader服务器上提交的事务最终被所有服务器提交：Leader服务器为每个Follower准备一个队列，并将未被各Follower服务器同步的事务以Proposal消息的形式逐个发送给Follower服务器，并在每一个Proposal后紧接着在发送一个Commit消息，表示该事务已经被提交。等到Follower服务器将所有其未同步的事务Proposal都从Leader中同步过来，并成功应用到本地数据库之中，Leader服务器就会将该Follower将入到真正可用的Follower列表中，并开始之后的流程。

ZAB协议需要确保丢弃那些只在Leader服务器上被提出的事务：ZAB协议的事务编号ZXID，是一个64位的数字，其中低32位可以看做是一个简单的单调递增的计数器，针对客户端的每一个事务请求，Leader服务器在产生一个新的事务Proposal时对计数器加1；而高32位则代表了Leader周期epoch的编号，每当选举产生一个新的Leader服务器，就会从这个Leader服务器上取出本地日志中最大事务Proposal的ZXID，并从该ZXID中解析队形的epoch值，然后在对其加1，之后以此标号作为新的epoch，并将低32位0开始生成新的ZXID。通过epoch标号的变化来区分Leader的变化，能够有效避免不同的Leader服务器错误使用相同的ZXID编号提出不一样的事务Proposal，简化和提升了数据恢复流程。

### ZAB算法描述

- TODO

## ZooKeeper 典型应用场景

### 数据发布/订阅

数据发布/订阅系统，即所谓的配置中心，顾名思义就是发布者将数据发布到ZooKeeper的一个或一系列的节点上，工订阅者进行数据订阅，进而达到动态获取数据的目的，实现配置信息的集中式管理和数据的动态更新。
发布/订阅系统一般有两种设计模式，分别是推（push）和拉（pull），ZooKeeper采取推拉结合的方式，客户端向服务端注册自己关注的节点，一旦节点的数据发生变更，那么服务端就会向相应的客户端发送Watcher事件通知，客户端收到通知之后，需要主动到服务端获取最新的数据。通常情况下，应用启动时候会主动到ZooKeeper服务端上进行一次配置信息获取，同时，在指定节点上注册一个Watcher监听，一旦配置反生变更，服务端会事实通知所有的订阅客户端，从而达到获取最新配置信息的目的。

数据库切换实现：

- 在ZooKeeper 上选取一个节点用于存储配置信息，例如：/app1/database_config
- 应用订阅节点/app1/database_config,并注册Watcher事件
- 应用启动从节点拉取数据库配置，初始化数据库连接
- 节点配置内容发生变化，自动push通知订阅节点的应用，应用手动pull最新内容，重新初始化数据库连接

### 负载均衡

基于ZooKeeper实现动态DNS方案 Dynamic DNS：

- 在ZooKeeper 上选取一个节点用于存储配置信息，例如：/DDNS/app1/server1.company1.com

- 应用订阅节点/DDNS/app1/,并注册Watcher事件

- 应用启动拉取DDNS/app1/节点下所有域名映射信息，并缓存到本地

- 服务调用，解析请求服务的域名，并替换实际ip,多个IP的话按照一定的策略返回一个IP，然后发起服务
- 后台进程定时检测服务可用状态，并剔除不可用服务

- 节点配置内容发生变化，自动push通知订阅节点的应用，应用手动pull最新内容，更新本地缓存

### 命名服务

每个节点都会维护一飞子节点的顺序队列实现：

- 分布式全局唯一ID
- 分布式服务注册发现

### 分布式协调/通知

MySQL Replicator  复制Binlog  通过ZooKeeper协调，防止重复复制

实现通用分布式系统机器间通信

- 心跳监测 创建临时节点--判断节点存在与否监测集群监控状态
- 任务进度汇报
- 系统调度

### 集群管理

- 分布式日志收集（kafka...）

- 在线云主机管理

### Master选举

多台主机同时创建同一个临时节点，创建成功的则为Master

### 分布式锁

排他锁

-创建临时节点，成功者获取到了锁，完成之后删除节点

共享锁

- 读请求-向比自己序号小的最后一个写请求节点注册Watcher监听
- 写请求-向比自己序号小的最后一个节点注册Watcher监听

### 分布式队列

排队-先进先出
排队-等到所有资源入库，一次性出（父节点定义资源个数，统计子节点个数，和预定义的数量一致，出库）

## ZooKeeper和Kafka

Kafka 是LinkedIn于2010年12月开源的分布式消息系统，主要使用Scala开发，主要用于实现低延迟的发送和收集大量的事件和日志数据。Kafka是一个吞吐量极高的分布式消息系统，整体设计是典型的发布与订阅模式，在Kafka集群中，没有“中心主节点”概念，集群中所有服务器都是对等的，可以做到不做任何配置修改的情况下实现服务器的添加和删除。

### Kafka术语介绍

- 消息生产者:Producer 消息的源头，负责生成消息并发送到Kafka服务器
- 消息消费者:Consumer 消息的使用者，负责消费Kafka服务器上的消息
- 主题:Topic,用户自定义并配置在Kafka服务端，用于建立生产者和消费者之间的订阅关系
- 消息的分区:Partition，一个Topic下可以都多个分区，消息的分区机制和分区数量与消费者的负债均衡有很大的关系
- Broker: Kafka服务器，用于存储消息
- 消费者分组: Group,归类同组消费者，同组的消费者可以消费一个Topic下的消息，每个消费者消费其中的部分消息
- Offset:消息存储在Kafka的Broker上，消费者拉取消息数据的过程中需要知道消息的文件中的偏移量，这个偏移量就是Offset

### Broker注册

Broker是分布式部署，并且相互之间独立运行，使用ZooKeeper进行所有Broker的管理。

- Kafka会在ZooKeeper维护一个专门用来记录Broker服务器列表记录的节点，其节点路径为"/brokers/ids"
- 每个Broker服务器启动时，都会到ZooKeeper上进行注册，在Broker服务器节点下创建属于自己的临时节点，其节点路径为"/brokers/ids/[0...N]",创建玩节点后，每个Broker会将自己的IP地址和端口号写入到该节点

### Topic注册

Kafka会将同一个Topic的消息分成多个分区并将其分布到多个Broker上，这些分区信息以及Broker对应的关系也由ZooKeeper进行维护

- Kafka会在ZooKeeper维护一个专门用来记录Topic列表记录的节点，其节点路径为"/brokers/topics"
- 每个Topic创建之后，，都会到ZooKeeper上进行注册，创建节点"/brokers/topics/topicname"
- Broker启动之后，会到Topic节点下注册自己的临时节点信息，并写入针对该Topic的分区总数，例如"brokers/topics/topicname/partitions"
