# Netty学习笔记

## I/O基础入门

### Linux 网络I/O模型

- 阻塞I/O模型: 最常用的I/O模型就是阻塞I/O模型，缺省情形下，所有文件操作都是阻塞的。在进程空间中调用recvfrom,其系统调用知道数据包到达且被复制到应用进程的缓冲区中或者发生错误才返回，在此期间一直会等待，进程在从调用recvfrom开始到它返回的正短时间内都是被阻塞的，因此被称为阻塞I/O模型。

- 非阻塞I/O模型：recvfrom从应用层到内核的时候，如果该缓冲区没有数据的话，就直接返回EWOULDBLOCK错误，一般都对非阻塞I/O模型进行轮询检查这个状态，看内核是不是有数据到来。

- I/O复用模型：Linux提供select/poll，进程通过将一个或多个fd传递个select或poll系统调用，阻塞在select操作上，这样select/poll可以帮我们侦测多个fd是否处于就绪状态。select/poll是顺序扫描fd是否就绪，二七日之策的fs数量有限，因此它的使用受到一些制约。Linux还提供了一个epoll系统调用，epoll使用局域事件驱动方式代替顺序扫描，因此性能更高。当有fd局叙事，立即回调函数rollback。

- 信号驱动I/O模型：首先开启带接口信号驱动I/O模型，并通过系统调动sigaction执行一个信号处理函数（此系统调用立即返回，进程继续工作，她是非阻塞的）。当数据准备就绪时，就位该进程生成一个SIGIO信号，通过信号回调通知应用程序调用recvfrom来读取数据，并通知主循环函数处理数据。

- 异步I/O模型：告知内核启动某个操作，并让内核在整个操作完成后（包括将数据从内核复制到用户的缓冲区）通知我们。这种模型与信号驱动模型的主要区别是:信号驱动I/O由内核通知我们何时可以开始一个I/O操作：异步I/O模型由内核通知我们I/O操作何时完成。

### I/O多路复用技术

- I/O多路复用技术：通过把多个I/O的阻塞复用到同一个select的阻塞上，从而使得系统在单线程的情况下可以同时处理多个客户端请求。与传统的多线程/多进程模型比，I/O多路复用的最大优势是系统开销小，系统不需要创建新的额外进程或者线程，也不需要维护这些进程和线程的运行，降低了系统的维护工作量，节省了系统资源。使用场景：

  - 服务器需要同时处理多个处于监听状态或者多个连接状态的套接字
  - 服务器需要同时处理多种网络协议的套接字

  支持I/O多路复用的xitong调用有select，pselect、poll、epoll,然而因为selectd饿一些独有缺陷导致它的使用受限.epoll和select的原理类似,为了克服select的缺陷，epoll做了如下改动：

  - 支持一个进程打开的socket描述符（FD）不受限制（仅受限于操作系统文件的最大文件句柄数）

    ```text
    select的最大缺陷就是单个进程所打开的FD是有一定的限制，它由FD_SETSIZE设置，默认值是1024。修改这个值需要重新编译内核，且会带来网络效益的下降。
    ```
  - I/O效率不会随着FD数目的增加而线性下降
  - 使用mmap加速内核与用户控件的消息传递
  - epoll的API更加简单

## NIO入门

- BIO的主要问题：每当有一个新的客户端请求接入时，服务端必须创建一个新的线程处理新接入的了护短链路，一个线程只能处理一个客户端连接。在高性能服务器应用领域。往往需要面对成千上万个客户端的并发连接，这种模型显然无法满足高性能、高并发接入场景。

- 伪异步I/O：后端通过一个线程池来处理多个客户端的请求接入，当有新的客户端接入时，将客户端的Socket封装成一个Task投递到线程池中进行处理，JDK的线程池维护一个消息队列和N个活跃的线程对消息队列中的任务进行处理。由于线程池可以设置消息队列的大小和最大线程数，因此，资源占用是可控的，无论多少个客户端并发访问，都不会导致资源的耗尽与宕机。依赖对方的处理速度，可靠性差，如响应时间过长，会引发级联故障。
